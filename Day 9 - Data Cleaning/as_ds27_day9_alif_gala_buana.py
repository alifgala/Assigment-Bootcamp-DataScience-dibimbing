# -*- coding: utf-8 -*-
"""AS_DS27_Day9_Alif Gala Buana.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Du5QV01NhY_TXnMLZHlvSXXbnIoWapX

# ASSIGNMENT DAY 9_Alif Gala *Buana* : DATA CLEANING

### Soal 1
#### Missing Values
Pertanyaan: Identifikasi kolom yang memiliki nilai yang hilang dan hitung persentase data yang hilang di setiap kolom.
"""

import pandas as pd
import numpy as np
import re

pd.set_option("display.max_columns",None)
df= pd.read_csv("linkdin_Job_data.csv")
df = df.drop(columns=['Column1'])
df

df.dtypes

df.info()

# persentase data yang hilang setiap kolom
df.isna().sum()/len(df)*100

"""### Soal 3
#### Data Type Correction
Pertanyaan: Kolom `no_of_employ` memiliki data numerik yang disimpan sebagai string. Ubah kolom ini menjadi tipe integer dan tangani nilai non-numerik dengan tepat.

"""

df["no_of_employ"].unique()

df[['Employees', 'Industry']] = df['no_of_employ'].str.split(' Â· ', expand=True)

df['Employees'] = df['Employees'].astype(str).str.replace(' employees', '', regex=False)

# Pisahkan informasi minimal dan maksimal karyawan
def extract_employee_range(employee_str):
    if pd.isna(employee_str):
        return pd.Series([None, None])
    if '-' in employee_str:
        min_employees, max_employees = employee_str.split('-')
        min_employees = min_employees.replace(',', '')
        max_employees = max_employees.replace(',', '')
        return pd.Series([min_employees, max_employees])
    elif '+' in employee_str:
        min_employees = employee_str.replace(',', '').replace('+', '')
        return pd.Series([min_employees, None])
    else:
        min_employees = employee_str.replace(',', '')
        return pd.Series([min_employees, min_employees])

df[['Min_Employees', 'Max_Employees']] = df['Employees'].apply(extract_employee_range)

# Hapus kolom 'Employees' jika sudah tidak diperlukan
df = df.drop(columns=['Employees'])
df= df.drop(columns=['Industry'])

df

df['Min_Employees'].unique()

"""### Soal 3
#### Duplicate Data Detection and Removal
Pertanyaan: Deteksi dan hapus posting pekerjaan yang duplikat berdasarkan `job_ID` Pastikan dataset yang dihasilkan hanya berisi posting pekerjaan yang unik.

"""

df["job_ID"].duplicated().sum()

df[df["job_ID"].duplicated()]

"""### SOAL 4
####Standarisasi Data
Pertanyaan: Standarisasi kolom `location` dengan memastikan semua nama kota ditulis dengan huruf besar dan konsisten (misalnya, "New York", "San Francisco").

"""

df = df.drop_duplicates(subset='job_ID', keep="first")

df["job_ID"].duplicated().sum()

df

df['location'].unique()

def split_location(loc):
    if pd.isna(loc):
        return pd.Series([np.nan, np.nan, np.nan], index=['city', 'province', 'country'])
    parts = loc.rsplit(', ', 2)
    if len(parts) == 3:
        return pd.Series(parts, index=['city', 'province', 'country'])
    elif len(parts) == 2:
        return pd.Series([np.nan] + parts, index=['city', 'province', 'country'])
    else:
        return pd.Series([np.nan, np.nan, parts[0]], index=['city', 'province', 'country'])

# Apply function to split location
df[['city', 'province', 'country']] = df['location'].apply(split_location)

df

df['city'].unique()

"""### SOAL 5
#### Deteksi dan Analisis Outlier
Pertanyaan: Identifikasi outlier pada kolom `no_of_application`. Definisikan outlier menggunakan metode IQR (Interquartile Range) dan berikan analisis singkat tentang temuan tersebut.


"""

df['no_of_application'].unique()

df['no_of_application'] = pd.to_numeric(df['no_of_application'], errors='coerce')

df = df.dropna(subset=['no_of_application'])

# Mengatur tipe data menjadi integer jika perlu
df['no_of_application'] = df['no_of_application'].astype(int)
df

Q1 = df['no_of_application'].quantile(0.25)
Q3 = df['no_of_application'].quantile(0.75)
IQR = Q3 - Q1

# Menentukan batas outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Mengidentifikasi outlier
outliers = df[(df['no_of_application'] < lower_bound) | (df['no_of_application'] > upper_bound)]
outliers

lower_bound

non_outliers = df[(df['no_of_application'] >= lower_bound) & (df['no_of_application'] <= upper_bound)]
non_outliers.describe()

plt.figure(figsize=(10, 6))
plt.hist(df['no_of_application'], bins=30, edgecolor='k', alpha=0.7)
plt.axvline(lower_bound, color='r', linestyle='--', label='Lower Bound')
plt.axvline(upper_bound, color='r', linestyle='--', label='Upper Bound')
plt.title('Histogram no_of_application ')
plt.xlabel('Number of Applications')
plt.ylabel('Frequency')
plt.legend()
plt.show()

"""#### Analisis sederhana

Garis batas atas berada di dibawah nilai 200, 200 menandakan titik tertinggi dari data. Ada beberapa data yang mencapai titik ini, yang bisa jadi merupakan outlier atau nilai ekstrem dalam dataset.

Mayoritas data terkumpul di sekitar angka 0 hingga 50 aplikasi. Namun, terdapat beberapa nilai yang jauh lebih tinggi yang tersebar hingga mendekati angka 200, yang berpotensi dianggap sebagai outlier, terutama jika jumlah aplikasi secara umum berkonsentrasi di angka yang lebih rendah.
"""